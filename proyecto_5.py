# -*- coding: utf-8 -*-
"""Proyecto 5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10UVK3dAYoKrNpOHuz0Ysa23Bj0Ah-fLg

Proyecto 5

# 1 Inicio
"""

import pandas as pd
import numpy as np
import seaborn as sns
from math import factorial
from scipy import stats as st
import math as mt
import matplotlib.pyplot as plt
from google.colab import drive
drive.mount('/content/drive')

users_df = pd.read_csv('/content/drive/MyDrive/Archivos TT/Proyecto 5/megaline_users.csv')
calls_df = pd.read_csv('/content/drive/MyDrive/Archivos TT/Proyecto 5/megaline_calls.csv')
messages_df = pd.read_csv('/content/drive/MyDrive/Archivos TT/Proyecto 5/megaline_messages.csv')
internet_df = pd.read_csv('/content/drive/MyDrive/Archivos TT/Proyecto 5/megaline_internet.csv')
plans_df = pd.read_csv('/content/drive/MyDrive/Archivos TT/Proyecto 5/megaline_plans.csv')

users_df.info()
calls_df.info()
messages_df.info()
internet_df.info()
plans_df.info()

"""## Usuarios/as

correccion de datos
"""

users_df['user_id']= users_df['user_id'].astype(str)
users_df['age']= users_df['age'].astype(str)

users_df['reg_date'] = pd.to_datetime(users_df['reg_date'])
users_df['reg_month'] = users_df['reg_date'].dt.month

"""## Llamadas

corrección de datos
"""

calls_df['user_id']= calls_df['user_id'].astype(str)
calls_df['call_date'] = pd.to_datetime(calls_df['call_date'])
calls_df['call_month'] = calls_df['call_date'].dt.month

"""## Mensajes

Corrección de datos
"""

messages_df['user_id']= messages_df['user_id'].astype(str)
messages_df['message_date'] = pd.to_datetime(messages_df['message_date'])
messages_df['message_month'] = messages_df['message_date'].dt.month

"""## Internet

Corrección de datos
"""

internet_df['user_id']= internet_df['user_id'].astype(str)
internet_df['session_date'] = pd.to_datetime(internet_df['session_date'])
internet_df['session_month'] = internet_df['session_date'].dt.month

"""# Estudiar las condiciones de las tarifas"""

plans_df.head()

"""Podemos apreciar que la diferencia entre un plan y otro, es el cobro entre las tarifas por exceso de uso de datos, donde el plan surf es 3 veces mayor que las tarifas del plan ultimate

## Agregar datos por usuario
"""

calls_p_month_user = calls_df.groupby(['user_id', 'call_month'], as_index=False).agg(calls_duration=('duration', 'sum'))
calls_p_month_user = calls_p_month_user.rename(columns={'duration':'calls_duration'})
calls_p_month_user.head()

msg_p_month = messages_df.groupby(['user_id', 'message_month'], as_index=False).agg({'id':'count'})
msg_p_month = msg_p_month.rename(columns={'id':'total_msg'})
msg_p_month.head()

internet_p_month = internet_df.groupby(['user_id', 'session_month'], as_index=False).agg({'mb_used':'sum'})
internet_p_month = internet_p_month.rename(columns={'mb_used':'total_mb'})
internet_p_month.head()

calls_p_month_user = calls_p_month_user.rename(columns={'call_month':'month'})
msg_p_month = msg_p_month.rename(columns={'message_month':'month'})
internet_p_month = internet_p_month.rename(columns={'session_month':'month'})

total_consume = pd.merge(calls_p_month_user, msg_p_month, on=['user_id', 'month'], how='outer')
total_consume = pd.merge(total_consume, internet_p_month, on=['user_id', 'month'], how='outer')
users_df = pd.merge(users_df, total_consume, on='user_id', how='outer')
users_df.head()

"""## Costo extra por exceso de consumo"""

def calcular_exceso(row):
    plan = row['plan'].lower()

    # Conversión de MB a GB
    internet_gb = row['total_mb'] / 1024

    # Configuración por plan
    if plan == 'surf':
        base = 20
        limites = {'llamadas': 500, 'mensajes': 50, 'internet': 15.36}
        tarifas = {'llamadas': 0.03, 'mensajes': 0.03, 'internet': 10.0}
    elif plan == 'ultimate':
        base = 70
        limites = {'llamadas': 3000, 'mensajes': 1000, 'internet': 30.72}
        tarifas = {'llamadas': 0.01, 'mensajes': 0.01, 'internet': 7.0}
    else:
        return None  # o puedes retornar 0 o un dict vacío

    # Cálculo de excesos
    exceso_llamadas = max(0, row['calls_duration'] - limites['llamadas'])
    exceso_mensajes = max(0, row['total_msg'] - limites['mensajes'])
    exceso_internet = max(0, internet_gb - limites['internet'])

    # Costo total por exceso
    costo_exceso = (
        exceso_llamadas * tarifas['llamadas'] +
        exceso_mensajes * tarifas['mensajes'] +
        exceso_internet * tarifas['internet']
    )

    total = base + costo_exceso

    return pd.Series([round(costo_exceso, 2), round(total, 2)])

# Aplicar función al DataFrame
users_df[['costo_exceso', 'total_pagar']] = users_df.apply(calcular_exceso, axis=1)

# Mostrar resultados
print(users_df[['user_id','first_name', 'plan', 'costo_exceso', 'total_pagar']])

"""# Comportamiento de usuario

## LLamadas
"""

users_df['reg_date'] = pd.to_datetime(users_df['reg_date'])

# Crear columna de año-mes
users_df['mes'] = users_df['reg_date'].dt.to_period('M').astype(str)

calls_avg = users_df.groupby(['plan', 'mes'])['calls_duration'].mean().reset_index()

# Cambiar nombre para claridad
calls_avg.rename(columns={'calls_duration': 'duracion_prom_llamadas'}, inplace=True)

plt.figure(figsize=(14, 6))
sns.barplot(data=calls_avg, x='mes', y='duracion_prom_llamadas', hue='plan')

plt.title("Duración promedio de llamadas por plan y mes", fontsize=16)
plt.xlabel("Mes")
plt.ylabel("Duración promedio (minutos)")
plt.xticks(rotation=30)
plt.legend(title="Plan")
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))

sns.histplot(data=users_df, x='calls_duration', hue='plan', bins=30, kde=True, element="step", stat="density")

plt.title("Distribución de minutos usados por los usuarios según el plan")
plt.xlabel("Minutos usados en llamadas")
plt.ylabel("Densidad")
plt.tight_layout()
plt.show()

"""Media y varianza"""

calls_mean = calls_avg.groupby('plan')['duracion_prom_llamadas'].mean()
calls_variance = calls_avg.groupby('plan')['duracion_prom_llamadas'].var()

"""Diagrama de caja"""

plt.figure(figsize=(11, 7))

sns.boxplot(data=calls_avg, x='plan', y='duracion_prom_llamadas', palette='viridis', legend = False)

plt.title('Distribución de la Duración Mensual de Llamadas por Plan', fontsize=16)
plt.xlabel('Plan')
plt.ylabel('Duración Promedio de Llamadas (minutos)')

plt.grid(axis='y', linestyle='--', alpha=0.7) # Add a grid for better readability
plt.show()

"""## Mensajes"""

users_df['reg_date'] = pd.to_datetime(users_df['reg_date'])

# Crear columna de año-mes
users_df['mes'] = users_df['reg_date'].dt.to_period('M').astype(str)

msg_avg = users_df.groupby(['plan', 'mes'])['total_msg'].mean().reset_index()

# Cambiar nombre para claridad
msg_avg.rename(columns={'total_msg': 'prom_msg'}, inplace=True)

plt.figure(figsize=(14, 6))
sns.barplot(data=msg_avg, x='mes', y='prom_msg', hue='plan')

plt.title("Total de mensajes por plan y mes", fontsize=16)
plt.xlabel("Mes")
plt.ylabel("Número de mensajes")
plt.xticks(rotation=30)
plt.legend(title="Plan")
plt.tight_layout()
plt.show()

"""Densidad"""

plt.figure(figsize=(10, 6))

sns.histplot(data=users_df, x='total_msg', hue='plan', bins=30, kde=True, element="step", stat="density")

plt.title("Distribución de mensajes usados por los usuarios según el plan")
plt.xlabel("Mensajes usados en sms")
plt.ylabel("Densidad")
plt.tight_layout()
plt.show()

"""Media y varianza"""

msg_mean = msg_avg.groupby('plan')['prom_msg'].mean()
msg_variance = msg_avg.groupby('plan')['prom_msg'].var()

"""Diagrama de caja"""

plt.figure(figsize=(11, 7))

sns.boxplot(data=msg_avg, x='plan', y='prom_msg', palette='viridis')

plt.title('Distribución de la cantidad de mensajes por Plan', fontsize=16)
plt.xlabel('Plan')
plt.ylabel('Cantidad de mensajes enviados')

plt.grid(axis='y', linestyle='--', alpha=0.7) # Add a grid for better readability
plt.show()

"""## Internet"""

users_df['reg_date'] = pd.to_datetime(users_df['reg_date'])

# Crear columna de año-mes
users_df['mes'] = users_df['reg_date'].dt.to_period('M').astype(str)

mb_avg = users_df.groupby(['plan', 'mes'])['total_mb'].mean().reset_index()

# Cambiar nombre para claridad
mb_avg.rename(columns={'total_mb': 'prom_mb'}, inplace=True)

plt.figure(figsize=(14, 6))
sns.barplot(data=mb_avg, x='mes', y='prom_mb', hue='plan')

plt.title("Total de Mb por plan y mes", fontsize=16)
plt.xlabel("Mes")
plt.ylabel("Número de Mb")
plt.xticks(rotation=30)
plt.legend(title="Plan")
plt.tight_layout()
plt.show()

"""Densidad"""

plt.figure(figsize=(9, 6))

sns.histplot(data=users_df, x='total_mb', hue='plan', bins=30, kde=True, element="step", stat="density")

plt.title("Distribución de Mb usados por los usuarios según el plan")
plt.xlabel("Mb usados")
plt.ylabel("Densidad")
plt.tight_layout()
plt.show()

"""Media y varianza"""

mb_mean = mb_avg.groupby('plan')['prom_mb'].mean()
mb_variance = mb_avg.groupby('plan')['prom_mb'].var()

"""Diagrama de caja"""

plt.figure(figsize=(11, 7))

sns.boxplot(data=mb_avg, x='plan', y='prom_mb', palette='viridis')

plt.title('Distribución de la cantidad de mensajes por Plan', fontsize=16)
plt.xlabel('Plan')
plt.ylabel('Cantidad de mensajes enviados')

plt.grid(axis='y', linestyle='--', alpha=0.7) # Add a grid for better readability
plt.show()

"""## Ingreso total por plan"""

total = users_df.groupby('plan')['total_pagar'].sum().reset_index()
print(total)

total.plot(kind='bar', x='plan', y='total_pagar') # Usar .plot() en lugar de .plt() y especificar x e y
plt.title("Ingreso Total por Plan")
plt.xlabel("Plan")
plt.ylabel("Ingreso Total")
plt.xticks(rotation=0) # Optional: keep labels horizontal
plt.tight_layout()
plt.show()

"""El plan surf preodmina en ingresos ya que las comisiones otorgadas por la penalidad de exceso del plan aon 3 veces mayor que en el plan ultimate, si la gente que contrata el plan surf contratara el plan ultimate, pagaría menos comisiones debido a la diferencia de datos que otorga el plan ultimate y sus comisiones

# Hipotesis, son diferentes el promedio de ingreso por usuario segun el plan
"""

income_surf = users_df[users_df['plan'] == 'surf']['total_pagar']
income_ultimate = users_df[users_df['plan'] == 'ultimate']['total_pagar']

p_value = st.ttest_ind(income_ultimate, income_surf, equal_var=False).pvalue # Access the pvalue directly

print(f"P-value: {p_value:.3f}")

alpha = 0.05

if p_value < alpha:
    print("Rechazo de hipotesis nula.")
    print("Conclusion: el promedio de ingresos de los usuarios del plan Ultimate es diferente al promedio de ingresos de los usuarios del plan Surf.")

else:
    print("Fallo al rechazar la hipotesis nula")
    print("Conclusion: no hay una diferencia significativa en los ingresos de los usuarios del plan Ultimate y del plan Surf.")

print()
print(f"Promedio de ingresos de los usuarios del plan Ultimate: {income_ultimate.mean():.2f}")

print(f"Promedio de ingresos de los usuarios del plan Surf:  {income_surf.mean():.2f}")

"""# Hipótesis consumo segun la región"""

ny_nj_cities = ['New York-Newark-Jersey City, NY-NJ-PA MSA']

# Filter users from the NY-NJ area
ny_nj_users_income = users_df[users_df['city'].isin(ny_nj_cities)]['total_pagar']

# Filter users from other regions
other_regions_users_income = users_df[~users_df['city'].isin(ny_nj_cities)]['total_pagar']

# Perform the independent t-test
ttest_result = st.ttest_ind(ny_nj_users_income, other_regions_users_income, equal_var=False)

# Access the p-value from the TtestResult object
p_value = ttest_result.pvalue

print(f"P-value: {p_value:.3f}")

alpha = 0.05

if p_value < alpha:
    print("Se rechaza la hipotesis nula")
    print("El promedio de los ingresos de los usuarios de NY-NJ es diferente al promedio de los ingresos de los usuarios de otras regiones.")

else:
    print("Fallo al rechazar la hipotesis nula")
    print("No hay una diferencia significativa en los ingresos de los usuarios de NY-NJ y de otras regiones.")

# Additionally, print the means for comparison
print(f"\nPromedio de ingresos para los usuarios de NY {ny_nj_users_income.mean():.2f}")
print(f"promedio de ingreso para los usuarios de otras regiones: {other_regions_users_income.mean():.2f}")

"""# Conclusión

Me doy cuenta que con tan poco datos proporiconados se puede desarrollar una gran cantidad de informacion y deducir muchas cosas dependiendo del area que se esté analizando, acá se calculó los ingresos por comisiones extras y los ingresos por cada región del pais, también comprendí que no siempre la mayor cantidad de ingresos se generan por los planes venidos, sino por las comisiones cobradas
"""